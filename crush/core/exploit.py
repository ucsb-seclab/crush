import json
import logging
import os

from greed import options
from greed.exploration_techniques import DFS, DirectedSearch
from greed.exploration_techniques.other import MstoreConcretizer
from greed.utils.exceptions import GreedException

from crush.attack import AttackRequest
# from crush.core.lifespan import recursive_bisect_partitions
from crush.ethpwn import check_feasibility
from crush.exploration_techniques import Simplifier, SSTOREStub, LoopLimiter, concretize
from crush.globals import w3
# from crush.masks import get_combined_mask
# from crush.sql import run_query
from crush.target import Target
from crush.utils import get_init_ctx


log = logging.getLogger(__name__)


ADDRESS = None
TARGET_BLOCK = None
CALLER = "0xaaA4a5495988E18c036436953AC87aadEa074550"


# def last_write_in_target(attack_request, slot_writes, target):
#     _masks = [int(_m, 16) for _m in attack_request.target2_types]
#     mask = f"{reduce(lambda x, y: x | y, _masks):064x}"

#     # filter slot writes to include only [target1.start, target1.end]
#     _slot_writes = [write for write in slot_writes 
#                     if attack_request.target1_window[0]-1 <= write[0] <= attack_request.target1_window[1]
#                     and write[1] == target.address]
    
#     if len(_slot_writes) == 0:
#         return False
    
#     abstract_target = Target("0x0", attack_request.proxy_address, target.address, None, None)
    
#     # scan all writes in reverse order
#     for block, addr, pc in _slot_writes[::-1]:
#         # skip if it's not a write to the base slot
#         # default to base slot if not found
#         if abstract_target.type_analysis["storage_accesses"].get(pc, dict()).get("is_base_slot", True) is False:
#             continue

#         # default to overlapping masks if not found
#         _write_types = abstract_target.type_analysis["storage_accesses"].get(pc, dict()).get("possible_types", attack_request.target2_types)
#         _write_types = [int(_m, 16) for _m in _write_types] or [0]
#         _write_mask = f"{reduce(lambda x, y: x | y, _write_types):064x}"

#         # skip if it does not overwrite any interesting bytes
#         if int(_write_mask, 16) & int(mask, 16) == 0:
#             continue
#         # else we found a write to the base slot that overwrites some interesting bytes
#         elif no_write_after_block(attack_request, _slot_writes, block):
#             # if no one wrote to the slot after this write, then it's the last write
#             return True
#         else:
#             # if someone wrote to the slot after this write, then it's not the last write
#             return False
#     # no slot writes with right type
#     return False


# def no_write_after_block(attack_request, slot_writes, threshold_block):
#     _masks = [int(_m, 16) for _m in attack_request.target2_types]
#     mask = f"{reduce(lambda x, y: x | y, _masks):064x}"

#     # filter slot writes to include only (target1, now]
#     _slot_writes = [write for write in slot_writes if threshold_block < write[0] <= TARGET_BLOCK]

#     if len(_slot_writes) == 0:
#         return True

#     abstract_targets = {addr: Target("0x0", attack_request.proxy_address, addr, None, None) for addr in set(list(zip(*_slot_writes))[1])}

#     # scan slot writes, if anyone wrote any bytes of mask
#     for block, addr, pc in _slot_writes:
#         # skip if it's not a write to the base slot
#         if abstract_targets[addr].type_analysis["storage_accesses"].get(pc, dict()).get("is_base_slot", False) is False:
#             continue

#         _write_types = abstract_targets[addr].type_analysis["storage_accesses"].get(pc, dict()).get("possible_types", list())
#         _write_types = [int(_m, 16) for _m in _write_types] or [0]
#         _write_mask = f"{reduce(lambda x, y: x | y, _write_types):064x}"
#         if int(_write_mask, 16) & int(mask, 16) != 0:
#             return False
#     return True


def directed_search_check(state, project, target_stmts, exit_stmts):
    if any({stmt in state.trace for stmt in target_stmts}) and any({stmt in state.trace for stmt in exit_stmts}):
        return True
    elif any({stmt in state.trace for stmt in target_stmts}):
        return any([DirectedSearch._is_reachable(state, project.block_at[exit_stmt.block_id], project.factory, project.callgraph)[0] for exit_stmt in exit_stmts])
    else:
        return any([DirectedSearch._is_reachable(state, project.block_at[stmt.block_id], project.factory, project.callgraph)[0] for stmt in target_stmts]) and \
               any([DirectedSearch._is_reachable(state, project.block_at[exit_stmt.block_id], project.factory, project.callgraph)[0] for exit_stmt in exit_stmts])


def directed_search_find(project, target_stmts, exit_stmts):
    # try to reach any write to target1's sstores with greed
    init_ctx = get_init_ctx(ADDRESS, TARGET_BLOCK)
    entry_state = project.factory.entry_state(xid=1, init_ctx=init_ctx, partial_concrete_storage=True)
    simgr = project.factory.simgr(entry_state=entry_state)
    simgr.use_technique(DFS())
    simgr.use_technique(Simplifier())
    # set each sstore to its current value because we know such value works (e.g., address with 
    # particular properties) and it proves that we can freely call the method without reverting
    simgr.use_technique(SSTOREStub(w3, ADDRESS, TARGET_BLOCK))
    simgr.use_technique(LoopLimiter(16))
    simgr.use_technique(MstoreConcretizer())
    for found in simgr.findall(find=lambda s: s.curr_stmt in exit_stmts,
                                prune=lambda s: not directed_search_check(s, project, target_stmts, exit_stmts)):
        # Resolve SHAs if any (this also fix the solutions in the solver in a new frame) (+1)
        try:
            # if len(found.sha_observed) > 0:
            #     shas = found.sha_resolver.fix_shas()
            #     if shas is not None:
            #         print(f'Fixed {len(shas)} shas in the state!')
            #     else:
            #         log.warning("Found dynamic path with greed. Could not concretize SHA3s")
            #         continue
            yield found
        except AssertionError:
            log.warning("Found dynamic path with greed. Could not concretize SHA3s")
            continue


def is_any_pc_reachable(target, pcs):
    target_stmts = {target.project.statement_at[pc] for pc in pcs}
    exit_stmts = target_stmts
    for found in directed_search_find(target.project, target_stmts, exit_stmts):
        # pcs_seen = {stmt.id for stmt in found.trace if stmt.id in pcs}
        pcs_seen_slots = {target.type_analysis["storage_accesses"][pc]["slot"] for pc in pcs}
        # get the full calldata
        calldatasize = concretize(found, found.calldatasize, force=True)
        calldata = found.solver.eval_memory(found.calldata, calldatasize)
        # instantiate at proxy's callsite (if needed)
        try:
            proxy_calldata = target.format_calldata(calldata, block_number=TARGET_BLOCK)
        except GreedException:
            log.error(f"Could not format calldata for state {found} (access control? unreachable target? incompatible 4-bytes?). Trying anyway with raw calldata...")
            proxy_calldata = calldata
            # log.info(f"Discarding state {found} because calldata could not be formatted (incompatible 4-bytes?)")
            # continue
        # verify with ethpwn
        verified, reverted = check_feasibility(proxy=ADDRESS, logic=target.address, sender=CALLER, block=TARGET_BLOCK, calldata=proxy_calldata, expected_sloads=pcs_seen_slots, expected_sstores=[])
        if (verified is False or reverted is True) and proxy_calldata != calldata:
            log.info(f"Failed to verify with formatted calldata. Trying with raw calldata...")
            raw_verified, raw_reverted = check_feasibility(proxy=ADDRESS, logic=target.address, sender=CALLER, block=TARGET_BLOCK, calldata=calldata, expected_sloads=pcs_seen_slots, expected_sstores=[])
            if raw_verified is True and raw_reverted is False:
                verified, reverted = raw_verified, raw_reverted
                proxy_calldata = calldata

        if verified is True:
            return True
        else:
            log.info(f"Discarding state {found} because it could not be verified")
            
    return False


def attack_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted_sensitive):
    # first check if target2 is actually alive and reachable
    log.info(f"Verifying if target2 is alive and its slot {attack_request.target2_slot} is readable...")
    is_any_target2_sload_reachable = is_any_pc_reachable(target2_target, attack_request.target2_sloads)
    if is_any_target2_sload_reachable is False:
        log.info(f"target2 is dead or its slot {attack_request.target2_slot} is not readable. Skipping attack...")
        return
    else:
        log.info(f"target2 is alive and its slot {attack_request.target2_slot} is readable. Continuing attack...")

    #######################################################################
    # corrupted? CORRUPTED SENSITIVE WARNING
    # can we write to A<slot> ? CONTROLLABLE SENSITIVE WARNING
    alive_str = "(" + ("ALIVE" if attack_request.target1_alive else "DEAD") + " " + ("ALIVE" if attack_request.target2_alive else "DEAD") + ")"

    controllable_sensitive = "N/A"
    log.info(f"{corrupted_sensitive=}")
    if corrupted_sensitive is True:
        log.warning(f"SENSITIVE {attack_request.attack_type.name} {alive_str} ATTACK. target2's sensitive slot {attack_request.target2_slot} was historically overwritten with wrong types from target1 ({attack_request.target1_types}). block={TARGET_BLOCK}, proxy={ADDRESS}, target1={attack_request.target1_address}, target2={attack_request.target2_address}, corrupted_sensitive={corrupted_sensitive}, controllable_sensitive={controllable_sensitive}")

    controllable_sensitive = False
    log.info(f"{attack_request.target1_alive=}")
    if attack_request.target1_alive is True:
        log.info("Attempting to find a path to overwrite the sensitive sstore")
        target_stmts = {target1_target.project.statement_at[pc] for pc in attack_request.target1_sstores}
        exit_stmts = {stmt for stmt in target1_target.project.statement_at.values() if stmt.__internal_name__ in {"STOP", "RETURN"}}
        for found in directed_search_find(target1_target.project, target_stmts, exit_stmts):
            sensitive_sstores_seen = {stmt.id for stmt in found.trace if stmt.id in attack_request.target1_sstores}
            sensitive_sstores_seen_slots = {target1_target.type_analysis["storage_accesses"][pc]["slot"] for pc in sensitive_sstores_seen}
            # get the full calldata
            calldatasize = concretize(found, found.calldatasize, force=True)
            calldata = found.solver.eval_memory(found.calldata, calldatasize)
            # instantiate at proxy's callsite (if needed)
            try:
                proxy_calldata = target1_target.format_calldata(calldata, block_number=TARGET_BLOCK)
            except GreedException:
                log.error(f"Could not format calldata for state {found} (access control? unreachable target? incompatible 4-bytes?). Trying anyway with raw calldata...")
                proxy_calldata = calldata
                # log.info(f"Discarding state {found} because calldata could not be formatted (incompatible 4-bytes?)")
                # continue
            # verify with ethpwn
            verified, reverted = check_feasibility(proxy=ADDRESS, logic=target1_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=proxy_calldata, expected_sloads=set(), expected_sstores=sensitive_sstores_seen_slots)
            if (verified is False or reverted is True) and proxy_calldata != calldata:
                log.info(f"Failed to verify with formatted calldata. Trying with raw calldata...")
                raw_verified, raw_reverted = check_feasibility(proxy=ADDRESS, logic=target1_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=calldata, expected_sloads=set(), expected_sstores=sensitive_sstores_seen_slots)
                if raw_verified is True and raw_reverted is False:
                    verified, reverted = raw_verified, raw_reverted
                    proxy_calldata = calldata

            if verified is True and reverted is False:
                controllable_sensitive = True
            elif reverted is True:
                controllable_sensitive = False
                log.info(f"Discarding state {found} because it reverted")
            elif verified is False:
                controllable_sensitive = False
                log.info(f"Discarding state {found} because it could not be verified")

            _not = "(NOT) " if not controllable_sensitive else ""
            log.warning(f"SENSITIVE {attack_request.attack_type.name} {alive_str} ATTACK. ({reverted=},{verified=}). {_not}Overwritten target2's sensitive slot {attack_request.target2_slot} with wrong types from target1 ({attack_request.target1_types}). block={TARGET_BLOCK}, proxy={ADDRESS}, target1={attack_request.target1_address}, target2={attack_request.target2_address}, proxy_calldata={proxy_calldata}, corrupted_sensitive={corrupted_sensitive}, controllable_sensitive={controllable_sensitive}")
    else:
        log.info(f"target1 is dead: the slot cannot be controllable")


def attack_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted_guarding):
    # first check if target2 is actually alive and reachable
    log.info(f"Verifying if target2 is alive and its slot {attack_request.target2_slot} is readable...")
    is_any_target2_sload_reachable = is_any_pc_reachable(target2_target, attack_request.target2_sloads)
    if is_any_target2_sload_reachable is False:
        log.info(f"target2 is dead or its slot {attack_request.target2_slot} is not readable. Skipping attack...")
        return
    else:
        log.info(f"target2 is alive and its slot {attack_request.target2_slot} is readable. Continuing attack...")

    #######################################################################
    # corrupted? CORRUPTED GUARDING WARNING
    # can we write to A<slot> ? CONTROLLABLE GUARDING WARNING
    # if corrupted or controllable:
    #     controllable? symbolize B<guarding>
    #     can we write B<guarding> -> B<guarded> ? CONTROLLABLE SENSITIVE WARNING
    alive_str = "(" + ("ALIVE" if attack_request.target1_alive else "DEAD") + " " + ("ALIVE" if attack_request.target2_alive else "DEAD") + ")"
    
    controllable_guarding = "N/A"
    controllable_sensitive = False
    log.info(f"{corrupted_guarding=}")
    if corrupted_guarding is True:
        log.warning(f"GUARDING {attack_request.attack_type.name} {alive_str} ATTACK. target2's guarding slot {attack_request.target2_slot} was historically overwritten with wrong types from target1 ({attack_request.target1_types}). block={TARGET_BLOCK}, proxy={ADDRESS}, target1={attack_request.target1_address}, target2={attack_request.target2_address}, corrupted_guarding={corrupted_guarding}, controllable_guarding={controllable_guarding}, controllable_sensitive={controllable_sensitive}")
        log.info("Attempting to find a path to overwrite the guarded sstore")
        target_stmts = {target2_target.project.statement_at[pc] for pc in attack_request.target2_guarded_sstores}
        exit_stmts = {stmt for stmt in target2_target.project.statement_at.values() if stmt.__internal_name__ in {"STOP", "RETURN"}}
        for found in directed_search_find(target2_target.project, target_stmts, exit_stmts):
            guarding_sloads_seen = {stmt.id for stmt in found.trace if stmt.id in attack_request.target2_sloads}
            guarding_sloads_seen_slots = {target2_target.type_analysis["storage_accesses"][pc]["slot"] for pc in guarding_sloads_seen}
            guarded_sstores_seen = {stmt.id for stmt in found.trace if stmt.id in attack_request.target2_guarded_sstores}
            guarded_sstores_seen_slots = {target2_target.type_analysis["storage_accesses"][pc]["slot"] for pc in guarded_sstores_seen}
            if len(guarding_sloads_seen) == 0:
                log.info(f"Discarding state {found} because it does not read from any guarding slot")
                continue
            # get the full calldata
            calldatasize = concretize(found, found.calldatasize, force=True)
            calldata = found.solver.eval_memory(found.calldata, calldatasize)
            # instantiate at proxy's callsite (if needed)
            try:
                proxy_calldata = target2_target.format_calldata(calldata, block_number=TARGET_BLOCK)
            except GreedException:
                log.error(f"Could not format calldata for state {found} (access control? unreachable target? incompatible 4-bytes?). Trying anyway with raw calldata...")
                proxy_calldata = calldata
                # log.info(f"Discarding state {found} because calldata could not be formatted (incompatible 4-bytes?)")
                # continue
            # verify with ethpwn
            verified, reverted = check_feasibility(proxy=ADDRESS, logic=target2_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=proxy_calldata, expected_sloads=guarding_sloads_seen_slots, expected_sstores=guarded_sstores_seen_slots)
            if (verified is False or reverted is True) and proxy_calldata != calldata:
                log.info(f"Failed to verify with formatted calldata. Trying with raw calldata...")
                raw_verified, raw_reverted = check_feasibility(proxy=ADDRESS, logic=target2_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=calldata, expected_sloads=guarding_sloads_seen_slots, expected_sstores=guarded_sstores_seen_slots)
                if raw_verified is True and raw_reverted is False:
                    verified, reverted = raw_verified, raw_reverted
                    proxy_calldata = calldata

            if verified is True and reverted is False:
                controllable_sensitive = True
            elif reverted is True:
                controllable_sensitive = False
                log.info(f"Discarding state {found} because it reverted")
            elif verified is False:
                controllable_sensitive = False
                log.info(f"Discarding state {found} because it could not be verified")

            _not = "(NOT) " if not controllable_sensitive else ""
            log.warning(f"GUARDING {attack_request.attack_type.name} {alive_str} ATTACK. ({reverted=},{verified=}). {_not}Overwritten target2's sensitive slots {guarded_sstores_seen_slots} through corrupted guard {attack_request.target2_slot}. block={TARGET_BLOCK}, proxy={ADDRESS}, target1={attack_request.target1_address}, target2={attack_request.target2_address}, proxy_calldata={proxy_calldata}, corrupted_guarding={corrupted_guarding}, controllable_guarding={controllable_guarding}, controllable_sensitive={controllable_sensitive}")

    controllable_guarding = False
    log.info(f"{attack_request.target1_alive=}")
    if attack_request.target1_alive is True:
        log.info(f"Checking if guarding slot is controllable")
        target_stmts = {target1_target.project.statement_at[pc] for pc in attack_request.target1_sstores}
        exit_stmts = {stmt for stmt in target1_target.project.statement_at.values() if stmt.__internal_name__ in {"STOP", "RETURN"}}
        for found in directed_search_find(target1_target.project, target_stmts, exit_stmts):
            guarding_sstores_seen = {stmt.id for stmt in found.trace if stmt.id in attack_request.target1_sstores}
            guarding_sstores_seen_slots = {target1_target.type_analysis["storage_accesses"][pc]["slot"] for pc in guarding_sstores_seen}
            # get the full calldata
            calldatasize = concretize(found, found.calldatasize, force=True)
            calldata = found.solver.eval_memory(found.calldata, calldatasize)
            # instantiate at proxy's callsite (if needed)
            try:
                proxy_calldata = target1_target.format_calldata(calldata, block_number=TARGET_BLOCK)
            except GreedException:
                log.error(f"Could not format calldata for state {found} (access control? unreachable target? incompatible 4-bytes?). Trying anyway with raw calldata...")
                proxy_calldata = calldata
                # log.info(f"Discarding state {found} because calldata could not be formatted (incompatible 4-bytes?)")
                # continue
            # verify with ethpwn
            verified, reverted = check_feasibility(proxy=ADDRESS, logic=target1_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=proxy_calldata, expected_sloads=[], expected_sstores=guarding_sstores_seen_slots)
            if (verified is False or reverted is True) and proxy_calldata != calldata:
                log.info(f"Failed to verify with formatted calldata. Trying with raw calldata...")
                raw_verified, raw_reverted = check_feasibility(proxy=ADDRESS, logic=target1_target.address, sender=CALLER, block=TARGET_BLOCK, calldata=calldata, expected_sloads=[], expected_sstores=guarding_sstores_seen_slots)
                if raw_verified is True and raw_reverted is False:
                    verified, reverted = raw_verified, raw_reverted
                    proxy_calldata = calldata

            if verified is True and reverted is False:
                controllable_guarding = True
                break
            elif reverted is True:
                controllable_guarding = False
                log.info(f"Discarding state {found} because it reverted")
            elif verified is False:
                controllable_guarding = False
                log.info(f"Discarding state {found} because it could not be verified")

            _not = "(NOT) " if not controllable_guarding else ""
            log.warning(f"GUARDING {attack_request.attack_type.name} {alive_str} ATTACK. ({reverted=},{verified=}). {_not}Overwritten target2's guarding slots {guarding_sstores_seen_slots} with wrong types from target1 ({attack_request.target1_types}). block={TARGET_BLOCK}, proxy={ADDRESS}, target1={attack_request.target1_address}, target2={attack_request.target2_address}, proxy_calldata={proxy_calldata}, corrupted_guarding={corrupted_guarding}, controllable_guarding={controllable_guarding}, controllable_sensitive={controllable_sensitive}")
    else:
        log.info(f"target1 is dead: the slot cannot be controllable")

    log.info(f"{controllable_guarding=}")
    if controllable_guarding:
        log.info(f"Attempting to find a path to overwrite the guarded sstore")
        # raise NotImplementedError("Symbolize the guarding slot")
        log.warning("Not Implemented: Symbolize the guarding slot")


def attack_collision_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target):
    global TARGET_BLOCK
    log.info(f"Trying attack at the target block ({TARGET_BLOCK})")
    corrupted = True if slot_writes is None else False  # last_write_in_target(attack_request, slot_writes, target1_target)
    attack_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted)


def attack_shift_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target):
    global TARGET_BLOCK
    log.info(f"Trying attack at the target block ({TARGET_BLOCK})")
    corrupted = True if slot_writes is None else False  # no_write_after_block(attack_request, slot_writes, attack_request.target1_window[1])
    attack_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted)
    # NOTE: target1 will always be dead, so 1) we cannot control it and 2) moving to the end of the window won't change the outcome


def attack_collision_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target):
    global TARGET_BLOCK
    log.info(f"Trying attack at the target block ({TARGET_BLOCK})")
    corrupted = True if slot_writes is None else False  # last_write_in_target(attack_request, slot_writes, target1_target)
    attack_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted)

        
def attack_shift_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target):
    global TARGET_BLOCK
    log.info(f"Trying attack at the target block ({TARGET_BLOCK})")
    corrupted = True if slot_writes is None else False  # no_write_after_block(attack_request, slot_writes, attack_request.target1_window[1])
    attack_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target, corrupted)
    # NOTE: target1 will always be dead, so 1) we cannot control it and 2) moving to the end of the window won't change the outcome


def run_exploit_analysis(attack_request_path):
    #######################################################################
    # read attack request
    #######################################################################
    if not os.path.exists(attack_request_path):
        log.error(f"Could not find attack request at {attack_request_path}")
        exit(1)
    with open(attack_request_path) as f:
        attack_request = f.read()

    attack_request = AttackRequest.from_dict(json.loads(attack_request))
    log.info(f"ATTACK REQUEST: {attack_request}")

    global ADDRESS, TARGET_BLOCK
    ADDRESS = attack_request.proxy_address
    TARGET_BLOCK = attack_request.target_block

    # # find changes in storage slot
    # impacted_bytes = get_combined_mask(attack_request.target1_types + attack_request.target2_types)
    # partitions = recursive_bisect_partitions(w3, attack_request.proxy_address, attack_request.slot, impacted_bytes, 0, attack_request.target_block)
    # relevant_blocks = [p[0] for p in partitions[1:]]
    
    # # find internal transactions with destination address = proxy address
    # relevant_transactions = defaultdict(set)
    # for block in relevant_blocks:
    #     transaction_hashes = run_query(f"select transaction_hash from transactions where block_number={block} and receiver='{attack_request.proxy_address}' union select transaction_hash from internal_transactions where block_number={block} and receiver='{attack_request.proxy_address}'")
    #     for tx_hash, in transaction_hashes:
    #         relevant_transactions[block].add(w3.eth.get_transaction(tx_hash).transactionIndex)

    # relevant_transactions = {k: sorted(list(v)) for k, v in relevant_transactions.items()}
    # for block, tx_indices in relevant_transactions.items():
    #     log.debug(f"Block {block}: {tx_indices}")
    #     analyze_historical_storage_accesses(block, tx_indices)

    log.info("Assuming worst case scenario for historical overwrites (everything is overwritten with wrong types)")
    slot_writes = None


    # #######################################################################
    # # setup
    # #######################################################################
    options.SOLVER_TIMEOUT = 60
    options.MAX_CALLDATA_SIZE = 512
    options.GREEDY_SHA = True
    options.MAX_SHA_SIZE = 300
    options.OPTIMISTIC_CALL_RESULTS = True
    options.DEFAULT_EXTCODESIZE = True

    proxy_target = Target("0x0", None, attack_request.proxy_address, None, None)
    target1_target = Target(attack_request.target1_pc, attack_request.proxy_address, attack_request.target1_address, attack_request.target1_window[0], attack_request.target1_window[1])
    target2_target = Target(attack_request.target2_pc, attack_request.proxy_address, attack_request.target2_address, attack_request.target2_window[0], attack_request.target2_window[1])


    #######################################################################
    # DISPATCH ATTACK TYPES
    #######################################################################
    if attack_request.attack_type == attack_request.ATTACK_TYPE.COLLISION and attack_request.is_target2_sensitive is True:
        attack_collision_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target)
    
    elif attack_request.attack_type == attack_request.ATTACK_TYPE.COLLISION and attack_request.is_target2_sensitive is False:
        attack_collision_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target)    
    
    elif attack_request.attack_type == attack_request.ATTACK_TYPE.SHIFT and attack_request.is_target2_sensitive is True:
        attack_shift_sensitive(attack_request, slot_writes, proxy_target, target1_target, target2_target)    
    
    elif attack_request.attack_type == attack_request.ATTACK_TYPE.SHIFT and attack_request.is_target2_sensitive is False:
        attack_shift_guarding(attack_request, slot_writes, proxy_target, target1_target, target2_target)    

    else:
        raise GreedException("Unknown attack type")
    